{% extends 'article.html' %}

{% block title %}Areas{% endblock %}

{% block article_header %}
<h1 class="article-header__headline">What if the election were tomorrow?</h1>
{% endblock %}

{% block article_body %}
<div id="slope-groups"></div>
{% endblock %}

{% block scripts %}
<script>

var d3 = require('d3');
var topojson = require('topojson');

document.addEventListener('o.DOMContentLoaded', function() {
  loaded();
});
</script>

<script>
//DATA PROCESSING this should be done server side
function constituencySlopeData(spreadsheet) { //takes a bertha JSON spreadsheet with the following sheets
  //data ... a list of lists of constituency ids
  //resultsnow ... constituency results as of the last election that took place there (by election or 2010 general)
  //details ... full constituency name, ft slug etc
  //predictions ... data from electionforecast.co.uk containing predicted 2015 results
  var output = [ ];

  spreadsheet.resultnow = makeLookup( spreadsheet.resultnow, 'id' );
  spreadsheet.predictions = makeLookup( spreadsheet.predictions, 'id' );
  spreadsheet.coordinates = makeLookup( spreadsheet.coordinates, 'id' );
  //create constituency objects
  var constituencies = spreadsheet.details.map(function(c){
    var now = resultNormalise( spreadsheet.resultnow[c.onsid] );
    var prediction = spreadsheet.predictions[c.onsid];
    var coords = spreadsheet.coordinates[c.onsid];
    var parties = [];
    for(var p in now){
      var record = {
        party: p,
        resultnow: now[p]
      };

      if(prediction){
        record.resultprediction = prediction[p]
      }
      parties.push(record);
    }

    //filter parties so it doesnt include parties with 0->0 or 0->undefined
    parties = parties.filter(function(p){
      if(p.resultprediction == 0 && p.resultnow == 0){
        return false;
      }
      return true;
    });
    var holderNowValue = 0 , holderNow,
    holderPredictedValue = 0, holderPredicted;
    for (var p in parties){
      if(parties[p].resultnow > holderNowValue){
        holderNowValue = parties[p].resultnow;
        holderNow = parties[p].party;
      }

      if(parties[p].resultprediction != undefined){
        if(parties[p].resultprediction > holderPredictedValue){
          holderPredictedValue = parties[p].resultprediction;
          holderPredicted = parties[p].party;
        }
      }
    }


    var o = {
      name: c.ftname,
      id: c.onsid,
      region: c.regionname,
      holdernow: holderNow,
      coords:[coords.lon, coords.lat,],
      holderpredicted: holderPredicted,
      parties: parties
    };
    return o;
  });
  constituencies = makeLookup(constituencies, 'id');

  for(var list in spreadsheet.data){
    spreadsheet.data[list] = {
      headline:spreadsheet.data[list].bucket,
      description:spreadsheet.data[list].description,
      constituencies:populateGroup(spreadsheet.data[list].constituencies, constituencies)
    }
    console.log(spreadsheet.data[list].headline);
    spreadsheet.data[list].partychanges = getPartyChanges(spreadsheet.data[list].constituencies);
  }

  return spreadsheet.data;


  //helpful functions...
  function getPartyChanges(list){
    //console.log(list)
    var summary = {total:0};
    list.forEach(function(d){
      summary.total ++;
      if(!(d.holdernow == d.holderpredicted)){
        if(!summary[d.holdernow]){ summary[d.holdernow] = {gain:0,loss:0,hold:0}; }
        if(!summary[d.holderpredicted]){ summary[d.holderpredicted] = {gain:0,loss:0,hold:0}; }
        summary[d.holdernow].loss ++;
        summary[d.holderpredicted].gain ++;
      }else{
        if(!summary[d.holdernow]){ summary[d.holdernow] = {gain:0,loss:0,hold:0}; }
        summary[d.holdernow].hold ++;
      }
    });

    return(summary);
  }

  function populateGroup(list, constituencies){
    return list.map( function(d){
      return constituencies[d];
    } ).sort();
  }

  function resultNormalise(r){ //transform the result data in percentages, use only parties for which we have predictions
    var normalised = {
      lab:0,
      c:0,
      ld:0,
      green:0,
      ukip:0,
      snp:0,
      pc:0
    }
    var pctScale = 100/r.votes;
    var remainder = 100;
    for(var party in normalised){
      normalised[party] = Math.round(r[party]*pctScale * 100)/100;
      remainder -= normalised[party];
    }
    normalised.other = remainder;
    return normalised;
  }

  function makeLookup(a, property){
    var o = {};
    a.forEach(function(d){
      o[d[property]] = d;
    });
    return o;
  }
}
</script>

<script>

  var mapURL = 'https://gist.githubusercontent.com/tomgp/8defaceafdce7a11cc7a/raw/991ac83d5a6905b7946fd49ce8bd71a1c986de4c/simplemap.topojson',
  partyShortName = {'lab':'Lab','c':'Con','ld':'LD','green':'Grn','ukip':'UKIP','snp':'SNP','dup':'DUP','sf':'SF','pc':'PC','alliance':'A'},
  dataURL = 'http://bertha.ig.ft.com/view/publish/ig/0AtxzL7xNk41FdHpvYkNPNlBnd1FXaUhFTXFUeG15VWc/basic,resultnow,details,predictions,coordinates';


  function loaded(){

    var graphics = document.graphics,

    width = 180,
    height = 80,
    margin = {top:10,left:10,bottom:10,right:80},
    slopeHeight = height - (margin.top + margin.bottom);

    var layout = graphics.slope.layout()
      .start(function(d){
        return d.resultnow;
      })
      .end(function(d){
        return d.resultprediction;
      })
      .domain([0,70])
      .range([slopeHeight,0]);

    var SVGSlope = graphics.slope.svg()
      .width(70)
      .radius(2)
      .endClass(function(d){
        return  ' end-point ' +d.data.party;
      })
      .startClass(function(d){
        return d.data.party + ' start-point'
      })
      .slopeClass(function(d){
        return d.data.party + ' slope'
      })
      .labelClass(function(d){
        return d.data.party + ' slope-label'
      })
      .label(function(d,i){
        if( i==0 ){
          return partyShortName[d.data.party];
        }
      });

      function status(response) {
        if (response.status >= 200 && response.status < 300) {
          return Promise.resolve(response)
        } else {
          return Promise.reject(new Error(response.statusText))
        }
      }

      function toJson(response) {
        return response.json();
      }

      Promise.all([
        fetch(dataURL).then(status).then(toJson),
        fetch(mapURL).then(status).then(toJson),
      ]).then(function onData(responses) {
        gotData(undefined, responses[0], responses[1])
      });

      function gotData(error, data, map){
        var groups = constituencySlopeData(data);
        var divs = d3.select('#slope-groups')
          .selectAll('div.group')
          .data(groups)
          .enter()
            .append('div')  //class="figure constituency-group constituency-group--slope o-grid-row" data-o-grid-colspan="12"
            .attr({
              'class':'figure constituency-group constituency-group--slope o-grid-row',
              'data-o-grid-colspan':12
            });

        divs.append('h2')
          .attr('class','article-body__subhead figure__title')
          .text(function(d){return d.headline; });

        var overview = divs.append('div')
          .attr({'data-o-grid-colspan':'12 S4 M3 L2'})
          .append('div')
            .attr({'class':'o-grid-row constituency-group__details'});

        overview.call(dataTable);
        overview.call(locator, map);
        divs.call(groupContainer);
      };

      function groupContainer(g){
        g = g.append('div')
          .attr({'data-o-grid-colspan':'12 S8 M9 L10'})
            .append('div')
              .attr({'class':'o-grid-row'});


        var divs = g.selectAll('div.constituency').data(function(d){
          return d.constituencies;
        }).enter()
          .append('div').attr({
            class: 'constituency-group__slope',
            'data-o-grid-colspan': '4 M3 L2 XL2'
          }).append('div').attr({
            class: 'constituency-group__slope-graphic'
          });

        divs.append('svg').attr({
          class:'slope-chart',
          'data-constituency':function(d){ return d.id; },
          viewBox:'0 0 ' + width + ' ' + height + '',
          preserveAspectRatio:'xMinYMid meet',
          width:width,
          height:height
        }).append('g').attr({
          transform: 'translate(' + margin.left + ',' + margin.top + ')'
        }).each(function(d){
          d3.select(this).selectAll('g.slope')
          .data(layout(d.parties).sort(function (a,b) {
            if(a.slopeEnd<b.slopeEnd) return -1
              if(a.slopeEnd>b.slopeEnd) return 1
                return 0;
              }))
              .call(SVGSlope)
        });

        divs.append('div')
          .attr({
            class: 'constituency-group__constituency-name'
          }).text(function(d) {
            return d.name;
          });
      }

    window.redrawSlopes = function(){
      SVGSlope.width(30);
      var chartSVGs = d3.selectAll('svg.slope-chart').each(function(d,i){
        var slopes = d3.select(this).selectAll('g.slope').call(SVGSlope.reposition);
      });

    }

  };


</script>

<script>

function dataTable(g){
  var table = g.append('div')
  .attr({
    'class':'constituency-group__data',
    'data-o-grid-colspan':12
  })
  .append('table')

  table.append('thead').html('<tr><th></th><th>Gain</th><th>Loss</th><th>Hold</th></tr>')
  table.append('tbody')
  .selectAll('tr').data(function(d) {
    return toArray(d.partychanges,'party','total').sort(function(a,b){
      var aMag = (a.gain + a.loss);
      var bMag = (b.gain + b.loss);
      if(aMag>bMag) return -1;
      if(aMag<bMag) return 1;
      if(a.party>b.party) return 1;
      if(a.party<b.party) return -1;
      return 0;
    });
  })
  .enter().append('tr').html(function(d) {
    return '<td class="' + d.party + ' rowhead">' + partyShortName[d.party] + '</td><td>+' + d.gain + '</td><td>-' + d.loss + '</td><td>' + d.hold + '</td>';
  });
}

//utility function for converting an object into and array, each keyed value becoming an element
function toArray(o, keyname, ignorekeys) {
  var a = [];
  if(!keyname) keyname = 'key';
  if(!ignorekeys) ignorekeys = [];
  for(var i in o){
    if(ignorekeys.indexOf(i)==-1){
      o[i][keyname] = i;
      a.push(o[i]);
    }
  }
  return a;
}

</script>


<script>

var locatorHeight = 300, locatorWidth = 200,
locatorProjection = projection = d3.geo.albers()
  .center([-2.5, 55.4])
  .rotate([0, 0])
  .parallels([50, 60])
  .scale(1500)
  .translate([locatorWidth / 2, locatorHeight / 2]),

  path = d3.geo.path().projection(locatorProjection);

function locator(g, map){
  var svg = g.append('div').attr('class','locator-container')
  .append('svg')
  .attr({
    viewBox:'0 0 ' + locatorWidth + ' ' + locatorHeight + '',
    width:locatorWidth,
    height:locatorHeight
  });

  svg.selectAll(".subunit")
  .data(topojson.feature(map, map.objects.subunits).features)
  .enter()
  .append("path")
  .attr("class", function(d) { return "subunit region-" + d.id.toLowerCase(); })
  .attr("d", path);

  svg.append("path")
  .datum(topojson.mesh(map, map.objects.subunits, function(a, b) { return a !== b && a.id !== "IRL"; }))
  .attr("d", path)
  .attr("class", "subunit-boundary");

  svg.append("path")
  .datum(topojson.mesh(map, map.objects.subunits, function(a, b) { return a === b && a.id === "IRL"; }))
  .attr("d", path)
  .attr("class", "subunit-boundary IRL");

  svg.each(function(group){
    console.log(group, this);
    d3.select(this).selectAll('circle')
    .data(group.constituencies)
    .enter()
    .append('circle')
    .attr({
      class: function(d){
        return 'constituency-point ' + (d.holderpredicted);
      },
      r:2,
      transform:function(d){
        return 'translate(' + locatorProjection(d.coords) + ')';}
      });
    });
  }

</script>
{% endblock %}
